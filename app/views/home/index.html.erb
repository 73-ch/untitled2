<script id="vs" type="x-shader/x-vertex">
    attribute vec3 color;
    attribute vec3 normals;
    uniform float time;

    varying vec3 vColor;

    vec2 random2(vec2 st){
      st = vec2( dot(st,vec2(127.1,311.7)),
      dot(st,vec2(269.5,183.3)) );
      return -1.0 + 2.0*fract(sin(st)*43758.5453123);
    }

    float noise(vec2 st) {
      vec2 i = floor(st);
      vec2 f = fract(st);

      vec2 u = f*f*(3.0-2.0*f);

      return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),
      dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),
      mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),
      dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);
    }

    void main() {
      vec3 t_pos = position + vec3(pow(noise(vec2(position.x, position.x)), 4. * time) * 10., noise(vec2((position.x + position.z)/20.0, time / 100.0)) * 50.0, 0);
      vec4 mvPosition = modelViewMatrix * vec4(t_pos, 1.0);

      gl_Position = projectionMatrix * mvPosition;
      gl_PointSize = 2.;
      vColor = color;
    }



</script>
<script id="fs" type="x-shader/x-fragment">
    precision highp float;
    varying vec3 vColor;
    void main() {
      gl_FragColor = vec4(vColor, 0.3);
    }



</script>


<script id="tvs" type="x-shader/x-vertex">
    attribute vec3 color;
    attribute vec3 normals;
    attribute float v_num;
    uniform float time;
    uniform float diff;

    varying vec3 vColor;

    vec2 random2(vec2 st){
      st = vec2( dot(st,vec2(127.1,311.7)),
      dot(st,vec2(269.5,183.3)) );
      return -1.0 + 2.0*fract(sin(st)*43758.5453123);
    }

    float noise(vec2 st) {
      vec2 i = floor(st);
      vec2 f = fract(st);

      vec2 u = f*f*(3.0-2.0*f);

      return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),
      dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),
      mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),
      dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);
    }

    void main() {
      vec3 t_pos = position + vec3(pow(noise(vec2(position.x, position.x)), 4. * time) * 10., noise(vec2((position.x + position.z)/20.0, time / 100.0)) * 50.0, 0);
      vec4 mvPosition = modelViewMatrix * vec4(t_pos, 1.0);

      gl_Position = projectionMatrix * mvPosition;
      gl_PointSize = 2.;
      vColor = vec3(0.588, 0.867, 0.847);
    }



</script>
<script id="tfs" type="x-shader/x-fragment">
    precision highp float;
    varying vec3 vColor;
    void main() {
      gl_FragColor = vec4(vColor, 0.3);
    }
</script>


<script id="tvs2" type="x-shader/x-vertex">
    attribute vec3 color;
    attribute vec3 normals;
    attribute float v_num;
    uniform float time;
    uniform float diff;

    varying vec3 vColor;

    vec2 random2(vec2 st){
      st = vec2( dot(st,vec2(127.1,311.7)),
      dot(st,vec2(269.5,183.3)) );
      return -1.0 + 2.0*fract(sin(st)*43758.5453123);
    }

    float noise(vec2 st) {
      vec2 i = floor(st);
      vec2 f = fract(st);

      vec2 u = f*f*(3.0-2.0*f);

      return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),
      dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),
      mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),
      dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);
    }

    void main() {
      vec3 t_pos = position;
      vec4 mvPosition = modelViewMatrix * vec4(t_pos, 1.0);

      gl_Position = projectionMatrix * mvPosition;
      gl_PointSize = 2.;
      vColor = vec3(0.561, 0.294, 0.667);
    }



</script>
<script id="tfs2" type="x-shader/x-fragment">
    precision highp float;
    varying vec3 vColor;
    void main() {
      gl_FragColor = vec4(vColor, 0.3);
    }
</script>


<script>
    let font;
    let camera;
    let camera_points = [];
    let slide = 0;
    let acceleration = 0;
    window.onload = () => {
        loadFont().then(() => {
            main();
        });
    };

    let loadFont = () => {
        return new Promise((resolve) => {
            let loader = new THREE.FontLoader();
            loader.load('../WebSubsetFont_Regular.json', function (response) {
                font = response;
                resolve(true);
            });
        });
    };
    let main = () => {
        let renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setClearColor(new THREE.Color().setRGB(255, 255, 255));

        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 10000);
        camera_points.push(490, 230, 1010);
        camera.position.x = 490;
        camera.position.y = 230;
        camera.position.z = 1010;
        camera.lookAt(0, 200, 0);

        let scene = new THREE.Scene();
        scene.color = 0xffffff;

        let text = new THREE.Group();

        let title = "Lightning Talk";
        title = title.split("");

        for (let i = 0; i < title.length; i++) {
            let t_mesh = createText(title[i], 50, 10, "tvs", "tfs");
            t_mesh.position.x = i * 50 + 400;
            t_mesh.position.y = 200;
            t_mesh.position.z = 300;

            text.add(t_mesh);
        }

        scene.add(text);



        let text2 = new THREE.Group();

        let title2 = "自己紹介";
        title2 = title2.split("");

        for (let i = 0; i < title2.length; i++) {
            let t_mesh = createText(title2[i], 50, 10, "tvs2", "tfs2");
            t_mesh.position.x = 300;
            t_mesh.position.y = 200;
            t_mesh.position.z = -800 - i * 50;
            t_mesh.rotation.y = Math.PI / 2;

            text2.add(t_mesh);
        }

        scene.add(text2);


        let p_geometry = new THREE.PlaneGeometry(3000, 3000);
        let p_material = new THREE.MeshBasicMaterial({color: 0x808080});
        let plane = new THREE.Mesh(p_geometry, p_material);
        plane.position.set(0, 0, 0);
        plane.rotation.x = -90 * Math.PI / 180;
        scene.add(plane);

        let particle_buffer = new THREE.BufferGeometry();

        let particles_verts = [];
        let particles_colors = [];

        for (let i = 0; i < 100000; i++) {
            let y = (Math.random() + Math.random() + Math.random() + Math.random()) / 5 * 10000 - 5000;
            let x = (Math.random() + Math.random() + Math.random() + Math.random()) / 5 * 10000 - 5000;
            let z = (Math.random() + Math.random() + Math.random() + Math.random()) / 5 * 10000 - 5000;

            let color = new THREE.Color();
            color.setRGB(0.1, 0.6 + Math.random() / 2, 0.3);

            for (let j = 0; j < 3; j++) {
                let offset_x = Math.random() * 50 - 25;
                let offset_y = Math.random() * 50 - 25;
                let offset_z = Math.random() * 50 - 25;

                particles_verts.push(x + offset_x, y + offset_y, z + offset_z);
                particles_colors.push(color.r, color.g, color.b);
            }
        }

        particles_verts = new Float32Array(particles_verts);
        particles_colors = new Float32Array(particles_colors);

        particle_buffer.addAttribute('position', new THREE.BufferAttribute(particles_verts, 3));
        particle_buffer.addAttribute('color', new THREE.BufferAttribute(particles_colors, 3));
        let particle_material = new THREE.ShaderMaterial({
            uniforms: {
                time: {
                    type: 'f',
                    value: 0.0
                }
            },
            vertexShader: document.getElementById('vs').textContent,
            vertexColors: THREE.VertexColor,
            fragmentShader: document.getElementById('fs').textContent,
            transparent: true,
            blending: THREE.NormalBlending
        });
        let particles = new THREE.Points(particle_buffer, particle_material);

        scene.add(particles);
        
        

        let stems_buffer = new THREE.BufferGeometry();

        let s_verts = [];
        let s_colors = [];

        for (let i = 0; i < 50000; i++) {
            let y = Math.random() * 400;
            let dx = 75 * Math.exp((Math.abs(Math.abs(y - 400) - 380) + Math.abs(y - 400) - 380) / 40);
            let dz = 75 * Math.exp((Math.abs(Math.abs(y - 400) - 380) + Math.abs(y - 400) - 380) / 40);
            let x = (Math.random() + Math.random() + Math.random() + Math.random()) / 5 * (50 + dx) - dx / 2;
            let z = (Math.random() + Math.random() + Math.random() + Math.random()) / 5 * (50 + dz) - 100 - dz / 2;
            y -= 50;
            let color = new THREE.Color();
            color.setRGB(0.53125, 0.28125, 0.0703125);

            for (let j = 0; j < 3; j++) {
                let offset_x = Math.random() * 10 - 5;
                let offset_y = Math.random() * 75 + 25;
                let offset_z = Math.random() * 50 - 5;

                s_verts.push(x + offset_x, y + offset_y, z + offset_z);
                s_colors.push(color.r, color.g, color.b);
            }
        }

        let leaves_buffer = new THREE.BufferGeometry();

        let l_verts = [];
        let l_colors = [];
        let l_normals = [];

        for (let i = 0; i < 100000; i++) {
            let y = (Math.random() + Math.random() + Math.random() + Math.random()) / 5 * 500 + 300;
            let x = (Math.random() + Math.random() + Math.random() + Math.random() + Math.random() + Math.random() + Math.random()) / 7 * 1000 - 500;
            let z = (Math.random() + Math.random() + Math.random() + Math.random()) / 5 * 1000 - 500;

            let color = new THREE.Color();
            color.setRGB(0.1, 0.6 + Math.random() / 2, 0.3);

            for (let j = 0; j < 3; j++) {
                let offset_x = Math.random() * 50 - 25;
                let offset_y = Math.random() * 50 - 25;
                let offset_z = Math.random() * 50 - 25;

                l_verts.push(x + offset_x, y + offset_y, z + offset_z);
                l_colors.push(color.r, color.g, color.b);
            }

            let vec1 = [l_verts[i + 3] - l_verts[i], l_verts[i + 4] - l_verts[i + 1], l_verts[i + 5] - l_verts[i + 2]];
            let vec2 = [l_verts[i + 6] - l_verts[i], l_verts[i + 7] - l_verts[i], l_verts[i + 8] - l_verts[i]];

            l_normals.push(vec1[1] * vec2[2] - vec1[2] * vec2[1]);
            l_normals.push(vec1[2] * vec2[0] - vec1[0] * vec2[2]);
            l_normals.push(vec1[0] * vec2[1] - vec1[1] * vec2[0]);
        }

        l_verts = new Float32Array(l_verts);
        l_colors = new Float32Array(l_colors);
        l_normals = new Float32Array(l_normals);

        leaves_buffer.addAttribute('position', new THREE.BufferAttribute(l_verts, 3));
        leaves_buffer.addAttribute('color', new THREE.BufferAttribute(l_colors, 3));
        leaves_buffer.addAttribute('normal', new THREE.BufferAttribute(l_normals, 3));
        let l_material = new THREE.ShaderMaterial({
            uniforms: {
                time: {
                    type: 'f',
                    value: 0.0
                }
            },
            vertexShader: document.getElementById('vs').textContent,
            vertexColors: THREE.VertexColor,
            fragmentShader: document.getElementById('fs').textContent,
            transparent: true,
            blending: THREE.NormalBlending
        });
        let leaves = new THREE.Mesh(leaves_buffer, l_material);

        scene.add(leaves);

        s_verts = new Float32Array(s_verts);
        s_colors = new Float32Array(s_colors);

        stems_buffer.addAttribute('position', new THREE.BufferAttribute(s_verts, 3));
        stems_buffer.addAttribute('color', new THREE.BufferAttribute(s_colors, 3));
        let s_material = new THREE.LineBasicMaterial({
            vertexColors: THREE.VertexColors,
            transparent: true,
            opacity: 0.3,
            blending: THREE.NormalBlending
        });
        let stems = new THREE.LineSegments(stems_buffer, s_material);

        scene.add(stems);


        let light = new THREE.DirectionalLight(0xffffff);
        light.position.set(1, 0, 0).normalize();
        scene.add(light);

        document.body.appendChild(renderer.domElement);
        renderer.render(scene, camera);

        window.THREE = THREE;
        window.scene = scene;

        let count = 0;
        let diff = 0.0;

        function render() {
            if (slide == 1) {
                diff += 0.1;
            }
            l_material.uniforms.time.value = acceleration;
            particle_material.uniforms.time.value = count;
            for (let i = 0; i < text.children.length; i++) {
                text.children[i].material.uniforms.time.value = count;
                if (slide == 1) {
                    text.children[i].material.uniforms.diff.value = diff;
                }
            }

            if (slide == 1) {

            }

            renderer.render(scene, camera);
            requestAnimationFrame(render);
            count++;
        }

        render();


        App.room = App.cable.subscriptions.create("RoomChannel", {
            connected: function () {
            },
            disconnected: function () {
            },
            received: function (data) {
                if (data['key']["slide"]) {
                    console.log(slide);
                    slide = data['key']["slide"];
                }

                if (data['key']["acceleration"]) {
                    console.log(acceleration);
                    acceleration += data['key']["acceleration"];
                }
            }
        });

        window.addEventListener("keydown", (e) => {
            if (e.keyCode == 40) {
                camera.position.y += 20;
            } else if (e.keyCode == 38) {
                camera.position.y -= 20;
            } else if (e.keyCode == 37) {
                camera.position.x -= 20;
            } else if (e.keyCode == 39) {
                camera.position.x += 20;
            } else if (e.keyCode ==13) {
                camera.position.z += 20;
            } else if (e.keyCode == 8) {
                camera.position.z -= 20;
            } else if (e.keyCode == 90) {
                camera.rotation.y += 0.1;
            } else if (e.keyCode == 88) {
                camera.rotation.y -= 0.1;
            }

            if (slide == 2) {
  //                createText()
            }

        });
    };

    let createText = (text, size, height, vs, fs) => {
        let color = new THREE.Color(0x96DDD8);
        let textGeo = new THREE.TextGeometry(text, {
            font: font,
            size: size,
            height: height,
            curveSegments: 10,
            material: 0,
            extrudeMaterial: 1,
            color: color
        });
        textGeo.computeBoundingBox();
        textGeo.computeVertexNormals();

        let vert_nums = [];

        for (var i = 0; i < textGeo.faces.length; i++) {
            var face = textGeo.faces[i];
            face.vertexColors[i] = color;
            vert_nums.push(i,i,i);
        }
        vert_nums = new Float32Array(vert_nums);

        let materialT = new THREE.ShaderMaterial({
            uniforms: {
                time: {
                    type: 'f',
                    value: 0.0
                },
                diff: {
                    type: 'f',
                    value: 0.0
                }
            },
            attributes: {
                v_num: {
                    value: vert_nums
                }
            },
            vertexShader: document.getElementById(vs).textContent,
            vertexColors: THREE.VertexColor,
            fragmentShader: document.getElementById(fs).textContent,
        });

        textMesh1 = new THREE.Mesh(textGeo, materialT);

        return textMesh1;
    }
</script>